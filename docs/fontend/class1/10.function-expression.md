# 函数表达式

##### 主要内容
> 函数表达式的特征    
> 使用函数实现递归      
> 使用闭包定义私有变量   


#### 定义函数的方式有两种: 函数声明、函数表达式


##### 1.函数声明：

```
function functionName(arg0, arg1, arg2) { 
    //函数体
}
```


* 特征：函数声明提升，意思是在执行代码之前会先读取函数声明。这就意味着可以把函数声明放在调用它的语句后面。

```
sayHi();
function sayHi(){
    alert("Hi!");
}
```
解析：不会抛出错误，因为在代码执行之前会先读取函数声明

##### 2.函数表达式

* 即创建一个函数并将它赋值给变量 functionName。 这种情况下创建的函数叫做匿名函数(也叫拉姆达函数)，因为 function 关键字后面没有标识符。
  
```
var functionName = function(arg0, arg1, arg2){ 
    //函数体
};
```



* 函数表达式与其他表达式一样，在使用前必须先赋值。

```
sayHi(); //报错:函数还不存在 
var sayHi = function(){
    alert("Hi!");
};
```




## 一、递归

#### 基础用法

> 递归函数是在一个函数通过名字调用自身的情况下构成的

递归阶乘函数：       
```
 function factorial(num){
    if (num <= 1) {
        return 1;
    } else { 
        return num * factorial(num-1);
    }
}
```

问题：
如上面的代码所示，在函数有名字，而且名字以后也不会变的情况下，这样定义没有问题。
若函数赋值给了另一个变量Anotherfactorial时，若factorial置为null，则Anotherfactorial 递归执行factorial，会报错；    
即这个函数的执行与函数名 factorial 紧紧耦合在了一起。

解决：为了消除这种紧密耦合的现象，可以像下面这样使用 arguments.callee



#### arguments.callee实现递归

前置知识：

> callee是arguments对象的属性。它可用于引用该函数的函数体内的当前正在执行的函数。     
> 当函数名称未知时，例如在没有名称的函数表达式中（也称为“匿名函数”），此功能很有用。

arguments.callee实现递归：

```
function factorial(num){
    if (num <= 1){
        return 1;
    } else {
        return num * arguments.callee(num-1);
    } 
}
```
通过使用 arguments.callee 代替函数名，可以确保无论怎样调用函数都不会出问题。
因此，在编写递归函数时，使用 arguments.callee 总比使用函数名更保险。


问题：但在**严格模式**下，不能通过脚本访问 arguments.callee，**访问这个属性会导致错误**。

解决：可以使用**命名函数表达式**来达成相同的结果。


#### 命名函数表达式实现递归

```
var factorial = (
    function f(num){
        if (num <= 1){
            return 1;
        } else {
            return num * f(num-1);
        } 
    }
);
```

解析：
以上代码创建了一个名为 f()的命名函数表达式，然后将它赋值给变量 factorial。
即便把函数赋值给了另一个变量，函数的名字 f 仍然有效，所以递归调用照样能正确完成。
这种方式在严格模式和 非严格模式下都行得通。




## 二、闭包

> 闭包是指有权访问**另一个函数作用域中的变量**的函数


##### 创建闭包的常见方式：就是在一个函数内部创建另一个函数

##### 当某个函数被调用时
* 会创建一个**执行环境**(execution context)及相应的**作用域链**。 
* 然后，使用 arguments 和其他命名参数的值来 **初始化**函数的**活动对象**(activation object)。
* 但在作用域链中，外部函数的活动对象始终处于第二位，......直至作为作用域链终点的全局执行环境

#### ① 当普通函数被调用实例分析

当普通函数被调用时实例：
```
function compare(value1, value2){
    if (value1 < value2){
        return -1;
    } else if (value1 > value2){
        return 1;
    } else {
        return 0; 
    }
}
```
图 7-1 展示了包含上述关系的 compare()函数执行时的作用域链。

实例分析：
* 在创建 compare()函数时，会**创建**一个预先包含全局变量对象的**作用域链**，这个作用域链被保存在内部的[[Scope]]属性中。
* 当调用 compare()函数时，会为函数创建一个执行环境，然后通过复制函数的[[Scope]]属性中的对象构建起执行环境的作用域链。此后，又有一个活动对象(在此作为变量对象使用)被创建并被推入执行环境作用域链的前端。
* 对于这个例子中 compare()函数的执行环境而言，其作用域链中包含两个变量对象:本地活动对象和全局变量对象。

总结：
* 后台的每个执行环境都有一个表示变量的对象——**变量对象**。
* 全局环境的变量对象始终存在，而像 compare()函数这样的局部环境的变量对象，则只在**函数执行的过程中存在**。
* 显然作用域链本质上是一个指向变量对象的指针列表，它只引用但不实际包含变量对象。
* 一般来讲，当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域(全局执行环境的变量对象)。



####  ② 当闭包函数被调用实例分析

当闭包函数被调用时实例：

```
//创建函数
var compareNames = createComparisonFunction("name"); //createComparisonFunction 内部定义了匿名函数
//调用函数
var result = compareNames({ name: "Nicholas" }, { name: "Greg" });
//解除对匿名函数的引用(以便释放内存)
compareNames = null;
```


图 7-2 展示调用 compareNames()的过程中产生的作用域链之间的关系。

实例分析：
* 创建的比较函数被保存在变量 compareNames 中。
* createComparisonFunction 内部定义了匿名函数；
* 在匿名函数从 createComparisonFunction()中被返回后，它的作用域链被初始化为包含 createComparisonFunction()函数的活动对象和全局变量对象。这样，匿名函数就可以访问在 createComparisonFunction()中定义的所有变量。
* createComparisonFunction() 函数在**执行完毕后**，其**活动对象也不会被销毁**，因为**匿名函数的作用域链仍然在引用这个活动对象**。
* 换句话说，其执行环境的作用域链会被销毁，但它的活动对象仍然会留在内存中;直到匿名函数被销毁后，createComparisonFunction()的活动对象才会被销毁。
* 由此有了第三步：通过将 compareNames 设置为等于 null 解除该函数的引用，就等于通知垃圾回收例程将其清除。

注意：
* 由于闭包会携带包含它的函数的作用域，因此会比其他函数占用更多的内存。
* 过度使用闭包可能会导致内存占用过多，我们建议读者只在绝对必要时再考虑使用闭包。


### 1.闭包与变量


### 2.关于this对象

### 3.内存泄漏


## 三、模仿块级作用域

## 四、私有变量

### 1.静态私有变量

### 2.模块模式

### 3.增强的模块模式


