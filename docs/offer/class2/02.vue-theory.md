

> [Vue 原理 -SY](https://www.mianshipai.com/docs/second-exam/vue-inner.html)   
> [剖析 Vue.js 内部运行机制 -掘金](https://juejin.cn/book/6844733705089449991?scrollMenuIndex=1)



### 1、响应式原理🌟🌟🌟🌟🌟

[参考：Vue 响应式原理-掘金](https://juejin.cn/post/7540323814777962530) 

> 核心目标是实现「数据驱动视图」—— 当数据发生变化时，依赖该数据的视图会自动更新，无需手动操作 DOM。


Vue 2 采用 🎯Object.defineProperty 对数据进行劫持，结合🎯「发布 - 订阅模式」实现响应式，核心流程包括数据劫持、依赖收集和触发更新三个环节。

Vue 3 的响应式系统基于 🎯 Proxy 代理和 🎯Effect 副作用机制实现，核心是建立“数据变化-副作用执行”的自动关联，流程可分为初始化、依赖收集、触发更新三个阶段。


<details>
  <summary>详细描述</summary>

#### Vue 2 的响应式

🎯 初始化阶段：

（1）通过 Object.defineProperty 为每个属性添加 get 和 set 拦截器，将普通对象转为响应式对象；  
（2）同时为每个属性创建对应的 Dep 实例（依赖管理器），用于存储依赖该属性的 Watcher。

```
// 递归将对象转为响应式
function observe(obj) {
  if (typeof obj !== 'object' || obj === null) {
    return; // 非对象类型无需处理
  }
  // 遍历对象属性，逐个劫持
  Object.keys(obj).forEach(key => {
    defineReactive(obj, key, obj[key]);
  });
}

// 劫持单个属性
function defineReactive(obj, key, val) {
  // 递归处理子对象（如 data 中的嵌套对象）
  observe(val);

  // 依赖管理器：收集依赖当前属性的订阅者
  const dep = new Dep();

  Object.defineProperty(obj, key, {
    get() {
      // 读取属性时，收集依赖（当前活跃的 Watcher）
      if (Dep.target) {
        dep.addSub(Dep.target); // 将 Watcher 加入依赖列表
      }
      return val;
    },
    set(newVal) {
      if (newVal === val) return; // 值未变化则不处理
      val = newVal;
      observe(newVal); // 新值如果是对象，需要递归劫持
      // 修改属性时，通知所有依赖更新
      dep.notify();
    }
  });
}

```



🎯 依赖收集阶段： 
当组件首次渲染时，会执行渲染函数，过程中会读取 data 中的属性，触发 get 拦截器。此时 Dep.target 指向当前组件的 Watcher，Dep 会将该 Watcher 加入订阅列表，完成依赖收集。

```
// Dep 类：每个响应式属性对应一个 Dep 实例，用于存储依赖该属性的所有 Watcher。

class Dep {
  static target = null; // 静态属性，指向当前活跃的 Watcher
  subs = []; // 存储订阅者（Watcher）

  // 添加订阅者
  addSub(sub) {
    this.subs.push(sub);
  }

  // 通知所有订阅者更新
  notify() {
    this.subs.forEach(sub => sub.update());
  }
}

```

```
// Watcher 类：组件的渲染逻辑、watch 选项、computed 属性等都会被包装成 Watcher。当依赖的数据变化时，Watcher 会触发更新（如重新渲染组件）。

class Watcher {
  constructor(vm, expOrFn, cb) {
    this.vm = vm; // 当前组件实例
    this.cb = cb; // 更新时执行的回调（如重新渲染）
    this.getter = expOrFn; // 依赖的表达式或渲染函数
    this.get(); // 初始化时触发 get，收集依赖
  }

  get() {
    Dep.target = this; // 标记当前活跃的 Watcher
    this.getter.call(this.vm); // 执行渲染函数，触发数据的 get 拦截
    Dep.target = null; // 重置，避免重复收集
  }

  // 数据变化时触发更新
  update() {
    this.cb(); // 如重新执行渲染函数
  }
}

```


🎯 触发更新阶段： 

当修改响应式数据时，会触发 set 拦截器，Dep 会调用 notify() 方法，通知所有订阅的 Watcher 执行 update()，最终触发组件重新渲染或 watch 回调，实现「数据变 → 视图变」。
(Watcher 会通过异步队列（避免频繁更新）触发最终操作)

#### Vue 2 响应式的局限性

由于 Object.defineProperty 的设计限制，Vue 2 存在以下问题：

* 无法监听对象新增 / 删除的属性：只能劫持初始化时已存在的属性，新增属性需通过 this.$set(obj, key, val) 手动触发响应式。
* 无法监听数组的部分操作：数组的索引修改（如 arr[0] = 1）、length 变化不会触发 set，因此 Vue 2 重写了数组的 7 个方法（push、pop、splice 等）以支持响应式。
* 深层对象递归劫持的性能问题：初始化时需递归劫持所有嵌套对象，数据结构复杂时可能影响性能。

#### Vue 3 的响应式 -待补充


> Vue 3.x 使用 Proxy通过代理对象拦截整个对象的操作，无需递归初始化所有属性，性能更好。
> Vue 3 的响应式系统基于 Proxy 代理和 Effect 副作用机制实现，核心是建立“数据变化-副作用执行”的自动关联，流程可分为初始化、依赖收集、触发更新三个阶段。

🎯 数据劫持：Proxy 拦截整个对象

Proxy 可以创建一个对象的代理，直接拦截对象的读取、修改、新增、删除等操作，无需逐个拦截属性，支持更全面的响应式劫持。


#### Vue 3 响应式的优势

* 支持对象新增 / 删除属性：Proxy 能拦截 set（新增）和 deleteProperty（删除）操作，无需手动调用 $set。
* 原生支持数组响应式：可监听数组索引修改、length 变化等，无需重写数组方法。
* 懒递归劫持：嵌套对象只有在被访问时才会创建代理，初始化性能更优。
* 支持复杂数据结构：如 Map、Set 等，Proxy 可拦截其 set、delete 等操作。


</details>


### 2、「异步更新」NextTick原理与实现🌟🌟🌟

[参考：因为不会手写nextTick又被面试官diss了](https://zhuanlan.zhihu.com/p/1917948435497190788) 

<details>
  <summary>结果</summary>
实现 nextTick 的基本思路：

异步执行：确保回调是在当前任务完成之后执行的。  
队列管理：如果多次调用 nextTick，确保它们按照顺序执行，而不是并发执行。  
立即执行：如果可能的话，在微任务队列中立即执行（利用 Promise）。  


前置知识：
* MutationObserver 是 JavaScript 内置的一个 API，用于监听 DOM 元素的变化并在变化发生时执行回调函数。它是 HTML5 新增的特性，主要用于高效追踪 DOM 结构的修改（如节点增删、属性变化等）

```


function nextTick(fn) {
  // 函数返回一个 Promise，允许调用者通过 .then() 来处理结果
  return new Promise((resolve, reject) => {
    // 判断dom 是否已经渲染完毕
    // 判断浏览器是否支持MutationObserver
    if (typeof MutationObserver !== 'undefined') {
      let app = document.getElementById('app')
      // MutationObserver 构造函数，接受一个回调函数作为参数
      const observer = new MutationObserver(() => {
        // 当观察到变化时，执行传入的回调 fn()
        // 执行完回调后断开观察
        observer.disconnect()
        const result = fn ? fn() : undefined
        resolve(result)
      })
      observer.observe(app, { attributes: true, childList: true, subtree: true }) // 监听app的子节点变化
      // resolve()
    } else {
      setTimeout(() => {
        const result = fn ? fn() : undefined
        resolve(result)
      }, 0)
    }
  })
}
```



</details>



### 3、「缓存机制」keep-alive的使用与实现🌟🌟🌟🌟🌟

[参考：SY]() 

keep-alive 是 Vue 提供的一个内置组件，用来缓存组件的状态，避免在切换组件时重新渲染和销毁，从而提高性能。

<details>
  <summary>场景 & 使用 & 实现</summary>

使用场景：
1. 频繁切换的组件
当需要频繁切换多个组件（如标签页、导航切换）时，使用 keep-alive 可以缓存不活跃的组件，避免每次切换都重新渲染。

```
<keep-alive>
  <component :is="currentComponent"></component>
</keep-alive>
```
2. 需要临时保留状态的组件，
如搜索页面切换到详情页后返回，保留之前的搜索关键词和结果列表。

3. 性能敏感的组件
对于渲染成本高的组件（如包含大量数据的表格、复杂的图表），使用 keep-alive 可以避免重复计算和 DOM 操作，减少性能消耗。

4. 路由切换场景
```
<keep-alive>
  <router-view v-if="$route.meta.keepAlive"></router-view>
</keep-alive>
<router-view v-if="!$route.meta.keepAlive"></router-view>
```

使用：

```
<template>
  <keep-alive>
    <component :is="currentComponent" />
  </keep-alive>
</template>
```

实现：

```
//  Map 数据结构是因为它可以通过 key 快速查找和操作缓存的组件
//  _activeCache 是一个 "状态标记容器"，它的核心意义是：
在众多缓存的组件中，快速定位和管理 "当前正在使用" 的组件，为后续的缓存优化、状态管理、生命周期控制等功能提供基础。

const KeepAliveImpl = {
  name: 'KeepAlive',
  // 已缓存的组件实例。
  _cache: new Map(), //用于存储所有被缓存的组件 vnode（虚拟节点）
  _activeCache: new Map(), //用于标记当前活跃的缓存组件

  render() {
    // 获取默认插槽中的第一个组件（即被 KeepAlive 包裹的组件）
    const vnode = this.$slots.default()[0] // 获取动态组件的 vnode
    // 生成缓存的 key（优先使用组件自身的 key，否则用组件类型的名称）
    const key = vnode.key || vnode.type.name

    // 如果缓存中存在该组件
    if (this._cache.has(key)) {
      // 从缓存中获取组件
      const cachedVnode = this._cache.get(key)
      // 将其标记为活跃状态
      this._activeCache.set(key, cachedVnode)
      // 返回缓存的组件（复用）
      return cachedVnode
    } else {
      // 未缓存，直接渲染新组件
      return vnode // 未缓存，直接渲染
    }
  },

  mounted() {
    const key = this.$vnode.key
    if (!this._cache.has(key)) {
      this._cache.set(key, this.$vnode)
    }
  },

  beforeDestroy() {
    const key = this.$vnode.key
    this._cache.delete(key)
  },
}
```

</details>


### 4、「双向绑定」-自定义组件如何实现 v-model 🌟🌟🌟

[参考：SY]() 

vue2中，自定义组件使用v-model,需组件内部定制value prop ,然后通过 this.$emit('input', newValue) 触发更新即可。

<details>
  <summary>vue2「vue3待补充」</summary>

自定义的组件实现：

```
<template>
  <input :value="value" @input="$emit('input', $event.target.value)" />
</template>
<script>
export default {
  props: ['value'],
}
</script>
```

使用方式：

```
<CustomInput v-model="searchText" />
```

v-model 其实是一个语法糖，上面的代码等价于：
`:value="searchText"`:  把 searchText 的值传给组件的 value prop 
`@input="searchText = $event"`  :听组件的 input 事件，更新 searchText 

```
<CustomInput 
  :value="searchText"  
  @input="searchText = $event" 
/>

```
</details>


### 5、Vue 模板编译的过程 🌟🌟🌟

[参考：SY]() 

* Vue 的模板编译过程是将开发者编写的模板语法（例如 和 v-bind 等）转换为 JavaScript 代码的过程（结果是生成 render 函数）。

* 发生时间：组件初始化的核心步骤之一，发生在 beforeCreate 之后、created 之前。为后续的 DOM 渲染（beforeMount 到 mounted 阶段）提供基础

* 它主要分为三个阶段：模板解析、AST优化 和 代码生成


<details>
  <summary>三个阶段</summary>
1️⃣ 模板解析

Vue 使用其解析器将 HTML 模板转换为 抽象语法树（AST）
如：

```
<div>
  <p>{{ message }}</p>
  <button v-on:click="handleClick">点击</button>
</div>
```

被解析成的 AST 类似于下面的结构：

```
{
    type: 1, // 节点类型：1 表示元素节点
    tag: 'div', // 元素的标签名
    children: [ // 子节点（嵌套的 HTML 元素）
        {
            type: 1, // 子节点是一个元素节点
            tag: 'p',
            children: [{
                type: 2, // 2 表示插值表达式节点
                expression: 'message' // 表达式 'message'
            }]
        },
        {
            type: 1, // 另一个元素节点
            tag: 'button',
            events: { // 事件监听
                click: 'handleClick' // 绑定 click 事件，执行 handleClick 方法
            },
            children: [{
                type: 3, // 文本节点
                text: '点击' // 按钮文本
            }]
        }
    ]
}
```

2️⃣ AST优化

Vue 在生成渲染函数前，会对 AST 进行优化。优化的核心目标是 **标记 静态节点**，在渲染时，Vue 可以跳过这些静态节点，提升性能。
> 静态节点指所有的渲染过程中都不变化的内容，比如 某个div标签内的静态文本

> 在 vue3 中，如果一个节点及其子树都不依赖于动态数据，那么该节点会被提升到渲染函数外部（静态提升），仅在组件初次渲染时创建。

3️⃣ 代码生成

生成渲染函数是编译的最终阶段，这个阶段会将优化后的 AST 转换成 JavaScript 渲染函数。

例如，像这样的模板：

```
<div id="app">{{ message }}</div>
```

最终会生成类似这样的渲染函数：

```
function render() {
  return createVNode(
    'div',
    {
      id: 'app',
    },
    [createTextVNode(this.message)]
  )
}
```

渲染函数的返回值是一个 虚拟 DOM（VDOM）树 ，Vue 会根据 虚拟 DOM 来更新实际的 DOM 。由于 渲染函数 被 Vue 的响应式系统包裹，当数据发生变化时，渲染函数会被重新执行生成新的虚拟 DOM，因此页面也会实时更新。

</details>


### 6、Vue 组件是如何渲染和更新的 🌟🌟🌟

[参考：SY]() 

Vue 组件的渲染和更新过程涉及从 模板编译 到 虚拟 DOM 的构建、更新和最终的实际 DOM 更新。下面是 Vue 组件渲染和更新的主要步骤：



<details>
  <summary>组件渲染 & 更新过程 </summary>

1️⃣ 组件渲染过程
Vue 的组件的渲染过程核心是其模板编译过程：

* 首先，Vue会通过其响应式系统完成组件的 data、computed 和 props 等数据和模板的绑定，这个过程Vue 会利用 Object.defineProperty（Vue2） 或 Proxy（Vue3） 来追踪数据的依赖，保证数据变化时，视图能够重新渲染。 
* 随后，Vue会将模板编译成渲染函数，这个渲染函数会在每次更新时被调用，从而生成虚拟 DOM。 
* 最终，虚拟DOM被渲染成真实的 DOM 并插入到页面中，组件渲染完成，组件渲染的过程中，Vue 会依次触发相关的生命周期钩子。

2️⃣ 组件更新过程

* 当组件的状态（如 data、props、computed）发生变化时，响应式数据的 setter 方法会让调用Dep.notify通知所有 订阅者Watcher ，重新执行渲染函数触发更新。

![up](https://www.mianshipai.com/assets/%E6%A8%A1%E6%9D%BF%E7%BC%96%E8%AF%91.xbq7db3C.png "组件渲染和更新")

* 渲染函数在执行时，会使用 diff 算法（例如：双端对比、静态标记优化等）生成新的虚拟DOM。计算出需要更新的部分后（插入、删除或更新 DOM），然后对实际 DOM 进行最小化的更新。
* 在组件更新的过程中，Vue 会依次触发beforeUpdate、updated等相关的生命周期钩子。

</details>

