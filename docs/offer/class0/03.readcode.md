

> [参考：JS读代码-SY](https://www.mianshipai.com/docs/written-exam/JS-reading.html) 


## JS 编译

#### 1、编译「变量提升、函数与变量声明优先级」

```
var func = 1
function func() {}
console.log(func + func)

```
<details>
  <summary>结果&分析</summary>

```
结果：2
```

编译阶段（提升发生） ：
- JavaScript 引擎在代码执行前会进行编译，此时会将 function func() {} 函数声明提升到当前作用域的顶部
- 同时也会将 var func 变量声明提升到作用域顶部，但 变量初始化（赋值为1）会留在原地
- 当函数声明和同名变量声明同时存在时， 函数声明的优先级高于变量声明

执行阶段 ：
- 首先执行 var func = 1 ，这会将之前提升的函数引用覆盖为数值 1
- 然后执行 function func() {} ，但由于变量已经被赋值，这个函数声明在执行阶段不会生效
- 最后执行 console.log(func + func) ，此时 func 的值是 1，所以 1 + 1 = 2

</details>


## JS 类型
## JS this
## JS 自由变量
## JS 闭包
## JS promise

## Promise执行顺序1「小米1」
 
 <details>
  <summary>Promise执行顺序「同步-异步（微任务-宏任务）</summary>

```
async function async1() {
    console.log('async1 start'); //2
    await async2();
    console.log('async1 end');//6
  }
  async function async2() {
    console.log('async2'); //3
  }
  
  console.log('script start'); //1
  
  setTimeout(function () {
    console.log('setTimeout');//8
  }, 0);
  
  async1();
  
  new Promise(function (resolve) {
    console.log('promise1'); //4
    resolve();
  }).then(function () {
    console.log('promise2');//7
  });
  console.log('script end'); //5



// 执行结果：

//   promise.js:10 script start
//   promise.js:2 async1 start
//   promise.js:7 async2
//   promise.js:19 promise1
//   promise.js:24 script end
//   promise.js:4 async1 end
//   promise.js:22 promise2
//   promise.js:13 setTimeout
```

JavaScript的事件循环遵循以下优先级：
> 1.首先执行所有同步代码 （执行栈）  
> 2.然后执行所有微任务 （Microtasks Queue）  
> 3. 最后执行宏任务 （Macrotasks Queue）  

逐行解析执行过程:
* script start （行10）：执行全局同步代码的第一条输出
* async1 start （行2）：调用async1()函数，执行其内部的同步代码
* *async2 （行7）：async1内部调用async2()，执行其同步代码
promise1 （行19）：创建Promise对象，执行其构造* 函数中的同步代码
* script end （行24）：执行全局最后一条同步代码
此时同步代码执行完毕，开始执行微任务队列：
* async1 end （行4）：async2()返回的Promise完成后，执行async1中await后面的代码
* promise2 （行22）：Promise构造函数中的resolve()触发then回调，作为微任务执行
* 微任务队列清空后，开始执行宏任务队列：
* setTimeout （行13）：执行setTimeout的回调函数

</details>




----

执行顺序？？
// 1、--------------------
// 「百度1」
const obj = {a: 1}
obj.a = 2 
const arr =[1,2]
arr =[] //报错 Uncaught TypeError: Assignment to constant variable.

// 注意：obj.a=2是允许的，因为只是修改对象的属性而不是重新赋值整个变量
// arr =[] 仍然不允许，因为const变量不能被重新赋值

----
function A() {}
var a = new A()
console.log(a.__proto__ === A.prototype) //true
console.log(a.prototype) //undefined
console.log(A.__proto__ === Function.prototype) //true

// 1、分析 console.log(a.__proto__ === A.prototype) //true
// - 当使用 new A() 创建对象时，JavaScript会将新创建的对象 a 的内部 [[Prototype]] （在浏览器中通过 __proto__ 访问）指向构造函数 A 的 prototype 属性。
// - 这是JavaScript原型继承机制的核心：实例对象通过 __proto__ 链接到其构造函数的原型对象。

// 2、分析 console.log(a.prototype) //undefined
// - prototype 属性 只存在于函数对象 上，用于存储将被所有实例共享的属性和方法。
// - a 是通过 new A() 创建的普通实例对象，不是函数，因此它没有 prototype 属性。

// 3、分析 console.log(A.__proto__ === Function.prototype) //true
// - 在JavaScript中， 函数本身也是对象 。当创建函数 A 时，它会被视为 Function 的实例。
// - 因此， A 的内部 [[Prototype]] （即 A.__proto__ ）会指向 Function.prototype ，这体现了JavaScript中函数的原型链结构。