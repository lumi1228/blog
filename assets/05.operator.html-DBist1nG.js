import{_ as i,a,d as l,g as e}from"./app-BXqgnaz2.js";const s={};function t(r,n){return e(),a("div",null,[...n[0]||(n[0]=[l(`<h1 id="操作符" tabindex="-1"><a class="header-anchor" href="#操作符"><span>操作符</span></a></h1><h2 id="操作符包含" tabindex="-1"><a class="header-anchor" href="#操作符包含"><span>操作符包含</span></a></h2><p>一元操作符、位操作符、布尔操作符、乘性操作符、加性操作符、关系操作符、相等操作符、条件操作符、赋值操作符、逗号操作符</p><h2 id="一元操作符" tabindex="-1"><a class="header-anchor" href="#一元操作符"><span>一元操作符</span></a></h2><h4 id="递增和递减操作符" tabindex="-1"><a class="header-anchor" href="#递增和递减操作符"><span>递增和递减操作符</span></a></h4><p>分为前置型和后置型：</p><ul><li>前置型应该位于要操作的变量之前</li><li>执行前置递增和递减操作时，变量的值都是在语句被求值以前改变的。</li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">var num1 = 2;</span>
<span class="line">var num2 = 20;</span>
<span class="line">var num3 = --num1 + num2; // 等于 21  num1先-1，后与num2相加</span>
<span class="line">var num4 = num1 + num2; // 等于 21</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>后置型则应该位于要操作的变量之后</li><li>递增和递减操作是在包含它们的语句被求 值之后才执行的</li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">var num1 = 2;</span>
<span class="line">var num2 = 20;</span>
<span class="line">var num3 = num1-- + num2; // 等于 22  后置--不影响语句的结果，num1 先与num2相加然后--</span>
<span class="line">var num4 = num1 + num2;  // 等于 21 </span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>递增和递减操作符遵循下列规则：</p><ul><li>在应用于 <strong>浮点数值</strong> 时，执行加减 1 的操作。</li><li>在应用于一个包含 <strong>有效数字字符的字符串</strong> 时，先将其<strong>转换为数字值</strong>，再执行加减 1 的操作。</li><li>在应用于一个 <strong>不包含有效数字字符的字符串</strong> 时，将变量的值设置为 <strong>NaN</strong></li><li>在应用于 <strong>布尔值 false true</strong> 时，先将其转换为 <strong>0 1</strong> 再执行加减 1 的操作。</li><li>在应用于 <strong>对象</strong> 时，先调用对象的 valueOf()方法取得一个可供操作的值。然后对该值应用前述规则。</li></ul><h4 id="一元加和减操作符" tabindex="-1"><a class="header-anchor" href="#一元加和减操作符"><span>一元加和减操作符</span></a></h4><p>一元加操作符以一个加号(+)表示：</p><ul><li>放在<strong>数值</strong>前面，对数值不会产生任何影响，</li><li>应用于<strong>非数值</strong>时，该操作符会像 <strong>Number()</strong> 转型函数一样对这个值执行转换。</li><li><strong>对象</strong>是先调用它们的 valueOf()和(或)toString()方法，再转换得到的值。</li></ul><p>一元减操作符主要用于表示负数：</p><ul><li>应用于<strong>数值</strong>时，该值会变成<strong>负数</strong>。</li><li>应用于<strong>非数值</strong>时，该操作符会像 <strong>Number()</strong> 转型函数一样对这个值执行转换。，最后再将得到的数值转换为负数</li></ul><p><strong>一元加和减操作符主要用于基本的算术运算，也可以用于转换数据类型。</strong></p><h2 id="位操作符" tabindex="-1"><a class="header-anchor" href="#位操作符"><span>位操作符</span></a></h2><p>位操作符用于在最基本的层次上，即按内存中表示数值的位来操作数值。 不常用不做梳理</p><h2 id="布尔操作符" tabindex="-1"><a class="header-anchor" href="#布尔操作符"><span>布尔操作符</span></a></h2><h4 id="逻辑非" tabindex="-1"><a class="header-anchor" href="#逻辑非"><span>逻辑非 (!)</span></a></h4><p>逻辑非操作符首先会将它的操作数转换为一个布尔值，然后再 对其求反。 逻辑非操作符遵循下列规则:</p><ul><li>如果操作数是一个<strong>对象</strong>，返回 false; <code>const o={a:1}; !o //false</code></li><li>如果操作数是一个<strong>非空字符串</strong>，返回 false;<code>!&quot;abc&quot; //false</code></li><li><ul><li>如果操作数是一个空字符串，返回 true; <code>!&quot;&quot; //true</code></li></ul></li><li>如果操作数是任意<strong>非 0 数值</strong>(包括 Infinity)，返回 false; <code>!Infinity //false</code></li><li>如果操作数是数值 0，返回 true; <code>!0 //true</code></li><li>如果操作数是 null，返回 true; <code>!null //true</code></li><li>如果操作数是 NaN，返回 true; <code>!NaN //true</code></li><li>如果操作数是 undefined，返回 true。 <code>!undefined //true</code></li></ul><p>同时使用两个逻辑非操作符，实际上就会模拟 Boolean()转型函数的行为 <code>!!0 //false</code></p><h4 id="逻辑与" tabindex="-1"><a class="header-anchor" href="#逻辑与"><span>逻辑与(&amp;&amp;)</span></a></h4><p>在两个操作数是布尔值的情况下，返回结果为布尔值。 在有一个操作数不是布尔值的情况下，逻辑与操作就不一定返回布尔值，遵循规则如下：</p><ul><li>如果第一个操作数是对象，则返回第二个操作数; <code>var obj={a:9}; obj &amp;&amp; 7 //7</code></li><li>如果第二个操作数是对象，则只有在第一个操作数的求值结果为 true 的情况下才会返回该 对象; <code>var obj={a:9}; 7 &amp;&amp; obj //{a:9}</code></li><li>如果两个操作数都是对象，则返回第二个操作数;</li><li>如果有一个操作数是 null，则返回 null;<code>1 &amp;&amp; NaN //NaN</code></li><li>如果有一个操作数是 NaN，则返回 NaN;</li><li>如果有一个操作数是 undefined，则返回 undefined。</li></ul><p>总结：逻辑与操作属于<strong>短路操作</strong>，如果第一个操作数是 <strong>false</strong>，则无论第二个操作数是什么值，结果都不再可能是 true 了；如果两个操作数都是 <strong>true</strong>，则取第二个操作数。</p><h4 id="逻辑或" tabindex="-1"><a class="header-anchor" href="#逻辑或"><span>逻辑或(||)</span></a></h4><p>在两个操作数是布尔值的情况下，返回结果为布尔值。 如果有一个操作数不是布尔值，逻辑或也不一定返回布尔值。</p><p>总结：逻辑或操作符也是<strong>短路操作符</strong>。如果第一个操作数的求值结果为 <strong>true</strong>，就不会对第二个操作数求值了，如果两个操作数都是 <strong>false</strong>，则取第二个操作数。</p><h2 id="乘性操作符" tabindex="-1"><a class="header-anchor" href="#乘性操作符"><span>乘性操作符</span></a></h2><blockquote><p>如果参与乘性计算的某个操作数不是数值，后台会先使用 Number()转型函数将其转换为数值</p></blockquote><h4 id="乘法" tabindex="-1"><a class="header-anchor" href="#乘法"><span>乘法 (*)</span></a></h4><p>在处理特殊值的情况下，遵循下列特殊的规则:</p><ul><li>如果有一个操作数是 NaN，则结果是 NaN;</li><li>如果是 Infinity 与 0 相乘，则结果是 NaN;</li><li>如果是 Infinity 与 非0数值相乘，则结果是 Infinity 或-Infinity，取决于有符号操作数 的符号;</li><li>如果是 Infinity 与 Infinity 相乘，则结果是 Infinity;</li><li>如果是 Infinity 被任何非零数值除，则结果是 Infinity 或-Infinity，取决于有符号操作 数的符号;</li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">NaN*2 //NaN</span>
<span class="line">Infinity*0 //NaN</span>
<span class="line">Infinity*7 //Infinity</span>
<span class="line">Infinity*Infinity //Infinity</span>
<span class="line">&quot;9&quot;*&quot;9&quot; //81</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="除法" tabindex="-1"><a class="header-anchor" href="#除法"><span>除法 (/)</span></a></h4><p>在处理特殊值的情况下，遵循下列特殊的规则:</p><ul><li>如果有一个操作数是 NaN，则结果是 NaN;</li><li>如果是 Infinity 被 Infinity 除，则结果是 NaN;</li><li>如果是零被零除，则结果是 NaN;</li><li>如果是非零的有限数被零除，则结果是 Infinity 或-Infinity <code>9/0 //Infinity</code></li><li>如果是 Infinity 被任何非零数值除，则结果是 Infinity 或-Infinity，取决于有符号操作 数的符号;</li><li>如果有一个操作数不是数值，则在后台调用 Number()将其转换为数值，然后再应用上面的规则</li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">NaN/2 //NaN</span>
<span class="line">Infinity/Infinity //NaN</span>
<span class="line">0/0 //NaN</span>
<span class="line">9/0 //Infinity</span>
<span class="line">Infinity/9 //Infinity</span>
<span class="line">9/Infinity //0</span>
<span class="line">0/9 //0</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="求模" tabindex="-1"><a class="header-anchor" href="#求模"><span>求模 (%)</span></a></h4><p>遵循下列的规则:</p><ul><li>如果操作数都是数值，执行常规的除法计算，返回除得的余数;</li><li>如果被除数是无穷大值而除数是有限大的数值，则结果是 NaN;</li><li>如果被除数是有限大的数值而除数是零，则结果是 NaN;</li><li>如果是 Infinity 被 Infinity 除，则结果是 NaN;</li><li>如果被除数是有限大的数值而除数是无穷大的数值，则结果是被除数;</li><li>如果被除数是零，则结果是零;</li><li>如果有一个操作数不是数值，则在后台调用 Number()将其转换为数值，然后再应用上面的规则。</li></ul><h2 id="加性操作符" tabindex="-1"><a class="header-anchor" href="#加性操作符"><span>加性操作符</span></a></h2><h4 id="加法操作符" tabindex="-1"><a class="header-anchor" href="#加法操作符"><span>加法操作符(+)</span></a></h4><p>如果两个操作符都是<strong>数值</strong>，执行常规的加法计算，然后根据下列规则返回结果:</p><ul><li>如果有一个操作数是 NaN，则结果是 NaN;</li><li>如果是 Infinity 加 Infinity，则结果是 Infinity;</li><li>如果是-Infinity 加-Infinity，则结果是-Infinity;</li><li>如果是 Infinity 加-Infinity，则结果是 NaN;</li><li>如果是+0 加+0，则结果是+0;</li><li>如果是-0 加-0，则结果是-0;</li><li>如果是+0 加-0，则结果是+0。</li></ul><p>不过，如果有一个操作数是<strong>字符串</strong>，那么就要应用如下规则:</p><ul><li>如果两个操作数都是字符串，则将第二个操作数与第一个操作数拼接起来;</li><li>如果<strong>只有一个操作数是字符串</strong>，则将另一个<strong>操作数转换为字符串</strong>，然后再将两个字符串拼接 起来。</li><li>如果有一个操作数是<strong>对象、数值或布尔值</strong>，则调用它们的 toString()方法取得相应的字符串值，然后再应用前面关于字符串的规则。</li><li>对于 undefined 和 null，则分别调用 String()函数并取得字符 串&quot;undefined&quot;和&quot;null&quot;。</li></ul><h4 id="减法操作符" tabindex="-1"><a class="header-anchor" href="#减法操作符"><span>减法操作符(-)</span></a></h4><p>如果两个操作符都是<strong>数值</strong>，执行常规的减法计算，然后根据下列规则返回结果:</p><ul><li><p>如果有一个操作数是 NaN，则结果是 NaN;</p></li><li><p>如果是 Infinity 减 Infinity，则结果是 NaN;</p></li><li><p>如果是-Infinity 减-Infinity，则结果是 NaN;</p></li><li><p>如果是 Infinity 减-Infinity，则结果是 Infinity;</p></li><li><p>如果是-Infinity 减 Infinity，则结果是-Infinity;</p></li><li><p>如果是+0 减+0，则结果是+0;</p></li><li><p>如果是+0 减-0，则结果是-0;</p></li><li><p>如果是-0 减-0，则结果是+0;</p></li><li><p>如果有一个操作数是<strong>字符串、布尔值、null 或 undefined</strong>，则先在后台调用 Number()函数将 其转换为数值，然后再根据前面的规则执行减法计算。如果转换的结果是 NaN，则减法的结果就是 NaN;</p></li><li><p>如果有一个操作数是对象，则调用对象的 valueOf()方法以取得表示该对象的数值。如果得到 的值是 NaN，则减法的结果就是 NaN。如果对象没有 valueOf()方法，则调用其 toString() 方法并将得到的字符串转换为数值。</p></li></ul><h2 id="关系操作符" tabindex="-1"><a class="header-anchor" href="#关系操作符"><span>关系操作符</span></a></h2><p>当关系操作符的操作数使用了非数值时，也要进行数据转换 或完成某些奇怪的操作。以下就是相应的规则：</p><ul><li>如果两个操作数都是数值，则执行数值比较。</li><li>如果两个操作数都是字符串，则比较两个字符串对应的字符编码值。</li><li>如果一个操作数是数值，则将另一个操作数转换为一个数值，然后执行数值比较。</li><li>如果一个操作数是布尔值，则先将其转换为数值，然后再执行比较。</li><li>如果一个操作数是对象，则调用这个对象的 valueOf()方法，用得到的结果按照前面的规则执 行比较。如果对象没有 valueOf()方法，则调用 toString()方法，并用得到的结果根据前面 的规则执行比较。</li></ul><p>常见问题：</p><h5 id="当比较字符串-23-是否小于-3-时-结果居然是-true" tabindex="-1"><a class="header-anchor" href="#当比较字符串-23-是否小于-3-时-结果居然是-true"><span>当比较字符串&quot;23&quot;是否小于&quot;3&quot;时，结果居然是 true？</span></a></h5><p>因为两个操作数都是字符串， 而字符串比较的是字符编码，将一个操作数改为数值，则将另一个操作数转换为一个数值，比较的结果就正常了:</p><h5 id="如果那个字符串不能被转换成一个合理的数值呢" tabindex="-1"><a class="header-anchor" href="#如果那个字符串不能被转换成一个合理的数值呢"><span>如果那个字符串不能被转换成一个合理的数值呢？</span></a></h5><p><code>var result = &quot;a&quot; &lt; 3; // false，因为&quot;a&quot;被转换成了 NaN</code> &quot;a&quot;不能转换成合理的数值，因此就被转换成了 NaN,根据规则，任何操作符与NaN进行关系比较，结果都是false。</p><h2 id="相等操作符" tabindex="-1"><a class="header-anchor" href="#相等操作符"><span>相等操作符</span></a></h2><p>核心 相等和不相等——先转换再比较 全等和不全等——仅比较而不转换。</p><h5 id="_1-相等和不相等" tabindex="-1"><a class="header-anchor" href="#_1-相等和不相等"><span>1. 相等和不相等 (==) (!=)</span></a></h5><p>在转换不同的数据类型时，相等和不相等操作符遵循下列基本规则:</p><ul><li>如果有一个操作数是布尔值，先将其转换为数值——false 转换为 0，而true 转换为 1;</li><li>如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将 字符串转换为数值;</li><li>如果一个操作数是对象，另一个操作数不是，则调用对象的 valueOf()方法，用得到的基本类 型值按照前面的规则进行比较;</li></ul><p>这两个操作符在进行比较时则要遵循下列规则。</p><ul><li>null 和 undefined 是相等的。</li><li>要比较相等性之前，不能将 null 和 undefined 转换成其他任何值。</li><li>如果有一个操作数是 NaN，则相等操作符返回 false，而不相等操作符返回 true。重要提示: 即使两个操作数都是 NaN，相等操作符也返回 false;因为按照规则，NaN 不等于 NaN。</li><li>如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象， 则相等操作符返回 true;否则，返回 false。</li></ul><h5 id="_2-全等和不全等" tabindex="-1"><a class="header-anchor" href="#_2-全等和不全等"><span>2. 全等和不全等 (===) (!==)</span></a></h5><ul><li>除了在比较之前不转换操作数之外，全等和不全等操作符与相等和不相等操作符比较规则一致（同上）。</li><li>由于相等和不相等操作符存在类型转换问题，而为了保持代码中数据类型的完整性，我们<strong>推荐</strong>使用全等和不全等操作符。</li></ul><h2 id="条件操作符" tabindex="-1"><a class="header-anchor" href="#条件操作符"><span>条件操作符</span></a></h2><p>语法：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line"> variable = boolean_expression ? true_value : false_value;</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="赋值操作符" tabindex="-1"><a class="header-anchor" href="#赋值操作符"><span>赋值操作符 (=)</span></a></h2><p>其作用就是把右侧的值赋给左侧的变量</p><p>每个主要算术操作符(以及个别的其他操作符)都有对应的复合赋值操作符。</p><ul><li>乘/赋值(*=);</li><li>除/赋值(/=);</li><li>模/赋值(%=);</li><li>加/赋值(+=);</li><li>减/赋值(=);</li><li>左移/赋值(&lt;&lt;=);</li><li>有符号右移/赋值(&gt;&gt;=);</li><li>无符号右移/赋值(&gt;&gt;&gt;=)。</li></ul><p>实例：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">var num = 10; </span>
<span class="line">num = num+ 10;</span>
<span class="line"></span>
<span class="line">等价于</span>
<span class="line"></span>
<span class="line">var num = 10; </span>
<span class="line">num += 10;</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这些操作符的主要目的就是简化赋值操作。使用它们不会带来任何性能的提升。</p><h2 id="逗号操作符" tabindex="-1"><a class="header-anchor" href="#逗号操作符"><span>逗号操作符</span></a></h2><p>逗号操作符可以在一条语句中执行多个操作</p><ul><li>逗号操作符多用于声明多个变量 <code>var num1=1, num2=2, num3=3;</code></li><li>逗号操作符还可以用于赋值。用于赋值时，逗号操作符总会返回表达式中的最后一项 <code>var num = (5, 1, 4, 8, 0); // num的值为0</code></li></ul>`,84)])])}const p=i(s,[["render",t]]),u=JSON.parse('{"path":"/fontend/class1/05.operator.html","title":"操作符","lang":"zh-CN","frontmatter":{},"git":{"updatedTime":1764128360000,"contributors":[{"name":"lumi","username":"lumi","email":"lumiya1228@gmail.com","commits":1,"url":"https://github.com/lumi"}],"changelog":[{"hash":"cf2f85e78da6745fae651d3e778926f1ac985f47","time":1764128360000,"email":"lumiya1228@gmail.com","author":"lumi","message":"docs: restructure front-end and offer sections, add new content and navigation links"}]},"filePathRelative":"fontend/class1/05.operator.md"}');export{p as comp,u as data};
