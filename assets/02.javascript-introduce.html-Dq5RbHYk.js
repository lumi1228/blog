import{_ as i,a as e,d as l,g as t}from"./app-BXqgnaz2.js";const c={};function r(s,a){return t(),e("div",null,[...a[0]||(a[0]=[l('<h1 id="javascript-简介" tabindex="-1"><a class="header-anchor" href="#javascript-简介"><span>JavaScript 简介</span></a></h1><blockquote><p>参考书籍：《JavaScript 入门经典》</p></blockquote><h3 id="完整的-javascript-的组成" tabindex="-1"><a class="header-anchor" href="#完整的-javascript-的组成"><span>完整的 JavaScript 的组成</span></a></h3><ul><li>核心(ECMAScript) 由 ECMA-262 定义，提供核心语言功能;</li><li>文档对象模型(DOM) 提供访问和操作网页内容的方法和接口;</li><li>浏览器对象模型(BOM) 提供与浏览器交互的方法和接口。</li></ul><h3 id="ecmascript组成部分" tabindex="-1"><a class="header-anchor" href="#ecmascript组成部分"><span>ECMAScript组成部分</span></a></h3><ul><li>语法</li><li>类型</li><li>语句</li><li>关键字</li><li>保留字</li><li>操作符</li><li>对象</li></ul><h3 id="文档对象模型-dom" tabindex="-1"><a class="header-anchor" href="#文档对象模型-dom"><span>文档对象模型(DOM)</span></a></h3><p>文档对象模型(DOM，Document Object Model)是针对 XML 但经过扩展用于 HTML 的应用程序编程接口(API，Application Programming Interface)。DOM 把整个页面映射为一个多层节点结构。HTML7 或 XML 页面中的每个组成部分都是某种类型的节点，这些节点又包含着不同类型的数据。 通过 DOM 的创建表示文档的树形图，开发人员获得了控制页面内容和结构的主动权。借助 DOM 提供的 API，开发人员可以轻松自如地删除、添加、替换或修改任何节点。</p><h5 id="dom1-级" tabindex="-1"><a class="header-anchor" href="#dom1-级"><span>DOM1 级</span></a></h5><ul><li>DOM Core：规定的是如何映射基于 XML 的文档结构，以便简化对文档中任意部分的访问和操作。</li><li>DOM HTML：在 DOM 核心的基础上加以扩展，添加了针 对 HTML 的对象和方法。</li></ul><h5 id="dom1-级-1" tabindex="-1"><a class="header-anchor" href="#dom1-级-1"><span>DOM1 级</span></a></h5><ul><li>DOM 视图(DOM Views):定义了跟踪不同文档(例如，应用 CSS 之前和之后的文档)视图的 接口;</li><li>DOM 事件(DOM Events):定义了事件和事件处理的接口;</li><li>DOM 样式(DOM Style):定义了基于 CSS 为元素应用样式的接口;</li><li>DOM 遍历和范围(DOM Traversal and Range):定义了遍历和操作文档树的接口。</li></ul><h5 id="dom3-级" tabindex="-1"><a class="header-anchor" href="#dom3-级"><span>DOM3 级</span></a></h5><ul><li>DOM3 级也对 DOM 核心进行了扩展，开始支持 XML 1.0 规范，涉及 XML Infoset、XPath和 XML Base。</li></ul><h3 id="浏览器对象模型-bom" tabindex="-1"><a class="header-anchor" href="#浏览器对象模型-bom"><span>浏览器对象模型(BOM)</span></a></h3><p>BOM 只处理浏览器窗口和框架，习惯上也把所有针对浏览器的 JavaScript 扩展 算作 BOM 的一部分： JS扩展内容：</p><ul><li>弹出新浏览器窗口的功能;</li><li>移动、缩放和关闭浏览器窗口的功能;</li><li>提供浏览器详细信息的 navigator 对象;</li><li>提供浏览器所加载页面的详细信息的 location 对象;</li><li>提供用户显示器分辨率详细信息的 screen 对象;</li><li>对 cookies 的支持;</li><li>像 XMLHttpRequest 和 IE 的 ActiveXObject 这样的自定义对象。</li></ul><h5 id="在html中使用javascript" tabindex="-1"><a class="header-anchor" href="#在html中使用javascript"><span>在HTML中使用JavaScript</span></a></h5><ul><li>所有<code>&lt;script&gt;</code>元素都会按照它们在页面中出现的先后顺序依次被解析。在不使用 defer 和 async 属性的情况下，只有在解析完前面<code>&lt;script&gt;</code>元素中的代码之后，才会开始解析后面 <code>&lt;script&gt;</code>元素中的代码。</li><li>由于浏览器会先解析完不使用 defer 属性的<code>&lt;script&gt;</code>元素中的代码，然后再解析后面的内容， 所以一般应该把<code>&lt;script&gt;</code>元素放在页面最后，即主要内容后面，<code>&lt;/body&gt;</code>标签前面。</li><li>使用 defer 属性可以让脚本在文档完全呈现之后再执行。延迟脚本总是按照指定它们的顺序执行。</li><li>使用 async 属性可以表示当前脚本不必等待其他脚本，也不必阻塞文档呈现。不能保证异步脚 本按照它们在页面中出现的顺序执行。</li><li>使用<code>&lt;noscript&gt;</code>元素可以指定在不支持脚本的浏览器中显示的替代内容。</li></ul>',19)])])}const o=i(c,[["render",r]]),d=JSON.parse('{"path":"/fontend/class1/02.javascript-introduce.html","title":"JavaScript 简介","lang":"zh-CN","frontmatter":{},"git":{"updatedTime":1764128360000,"contributors":[{"name":"lumi","username":"lumi","email":"lumiya1228@gmail.com","commits":1,"url":"https://github.com/lumi"}],"changelog":[{"hash":"cf2f85e78da6745fae651d3e778926f1ac985f47","time":1764128360000,"email":"lumiya1228@gmail.com","author":"lumi","message":"docs: restructure front-end and offer sections, add new content and navigation links"}]},"filePathRelative":"fontend/class1/02.javascript-introduce.md"}');export{o as comp,d as data};
