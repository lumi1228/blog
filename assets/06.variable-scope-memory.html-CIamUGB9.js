import{_ as e,a as n,d as s,g as l}from"./app-BXqgnaz2.js";const i={};function r(t,a){return l(),n("div",null,[...a[0]||(a[0]=[s(`<h1 id="变量、作用域和内存" tabindex="-1"><a class="header-anchor" href="#变量、作用域和内存"><span>变量、作用域和内存</span></a></h1><h5 id="目标" tabindex="-1"><a class="header-anchor" href="#目标"><span>目标</span></a></h5><blockquote><p>理解基本类型和引用类型的值<br> 理解执行环境<br> 理解垃圾收集</p></blockquote><h2 id="一、基本类型和引用类型的值" tabindex="-1"><a class="header-anchor" href="#一、基本类型和引用类型的值"><span>一、基本类型和引用类型的值</span></a></h2><blockquote><p>ECMAScript 变量可能包含两种不同数据类型的值:基本类型值和引用类型值。<br> 基本类型值指的是简单的数据，基本类型是<strong>按值访问</strong>的，基本类型的值保存在<strong>变量中的实际的值</strong>。<br> 引用类型值指那些可能由多个值构成的对象，引用类型的值是<strong>按引用访问</strong>的，引用类型的值是保存在<strong>内存中的对象</strong>。<br> JavaScript 不允许直接访问内存中的位置， 也就是说不能直接操作对象的内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。</p></blockquote><h4 id="动态的属性" tabindex="-1"><a class="header-anchor" href="#动态的属性"><span>动态的属性</span></a></h4><ul><li>对于引用类型的值，可以为其添加属 性和方法，也可以改变和删除其属性和方法。</li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">var person = new Object(); </span>
<span class="line">person.name = &quot;Nicholas&quot;; a</span>
<span class="line">lert(person.name); //&quot;Nicholas&quot;</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>对于基本类型的的值，不能添加属性( 不会报错，但添加不成功)。</li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">var name = &quot;Nicholas&quot;;</span>
<span class="line">name.age = 27;</span>
<span class="line">alert(name.age);      //undefined</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="复制变量值" tabindex="-1"><a class="header-anchor" href="#复制变量值"><span>复制变量值</span></a></h4><ul><li>复制基本类型的值时，会在变量对象上创建一个新值，然后把该<strong>值</strong>复制到为新变量分配的位置上。</li><li>复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到为新变量分配的空间中。不同的是，这个值的<strong>副本实际上是一个指针</strong>，而这个指针指向<strong>存储在堆中的一个对象</strong>。复制操作结束后，两个变量实际上将<strong>引用同一个对象</strong>。因此，改变其中一个变量，就会影响另一个变量。</li></ul><h4 id="传递参数" tabindex="-1"><a class="header-anchor" href="#传递参数"><span>传递参数</span></a></h4><blockquote><p>ECMAScript 中所有函数的参数都是按值传递的。<br> 也就是说，把函数外部的值复制给函数内部的参数，就和把值从一个变量复制到另一个变量一样。<br> 基本类型值的传递，如同基本类型变量的复制一样；而引用类型值的传递，则如同引用类型变量的复制一样。 在引用类型值的传递时，即使在函数内部修改了参数的值，但原始的引用仍然保持未变。实际上，当在函数内部重写 obj 时，这个变量引用的就是一个局部对象了。而这个局部对象会在函数执行完毕后立即被销毁。</p></blockquote><ul><li>可以把 ECMAScript 函数的参数想象成局部变量。</li></ul><h4 id="检测类型" tabindex="-1"><a class="header-anchor" href="#检测类型"><span>检测类型</span></a></h4><ul><li>typeof 操作符 是确定一个变量是 字符串、数值、布尔值、 undefined 、null、对象、函数的最佳工具，但在无法检测其他引用类型的值。</li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">var u;</span>
<span class="line">function fn(){</span>
<span class="line">    console.log(&#39;fn&#39;)</span>
<span class="line">}</span>
<span class="line">alert(typeof u); undefined</span>
<span class="line">alert(typeof &quot;str&quot;); //string</span>
<span class="line">alert(typeof 123); //number</span>
<span class="line">alert(typeof true); //boolean</span>
<span class="line">alert(typeof null);  //object</span>
<span class="line">alert(typeof new Object()); //object</span>
<span class="line">alert(typeof fn); //function</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>instanceof 操作符原理：如果变量是给定引用类型(根据它的原型链来识别，第6章将介绍原型链)的实例，那么 instanceof 操作符就会返回 true。</li></ul><h2 id="二、执行环境及作用域" tabindex="-1"><a class="header-anchor" href="#二、执行环境及作用域"><span>二、执行环境及作用域</span></a></h2><h4 id="执行环境" tabindex="-1"><a class="header-anchor" href="#执行环境"><span>执行环境</span></a></h4><blockquote><p><strong>执行环境</strong>定义了变量或函数有权访问的其他数据，决定了它们各自的行为。<br> 每个执行环境都有一个与之关联的 <strong>变量对象</strong>(variable object)，环境中定义的所有****变量和函数都保存在这个对象中**。</p></blockquote><h5 id="_1-执行环境特点" tabindex="-1"><a class="header-anchor" href="#_1-执行环境特点"><span>1. 执行环境特点：</span></a></h5><ul><li>全局执行环境是最外围的一个执行环境。</li><li>在 Web 浏览器中，全局执行环境被认为是 window 对象.</li><li>每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。 而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。</li><li>某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁(全局执行环境直到应用程序退 出——例如关闭网页或浏览器——时才会被销毁)。</li></ul><h5 id="_2-执行环境延伸" tabindex="-1"><a class="header-anchor" href="#_2-执行环境延伸"><span>2. 执行环境延伸</span></a></h5><ul><li>当代码在一个环境中执行时，会创建变量对象的一个<strong>作用域链</strong>；</li><li>作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。</li><li>全局执行环境的变量对象始终都是作用域链中的最后一个对象。</li><li>内部环境可以通过作用域链访问所有的外部环境，但 外部环境不能访问内部环境中的任何变量和函数。</li><li><strong>函数参数</strong>也被当作变量来对待，因此其访问规则与执行环境中的其他变量相同。</li></ul><h4 id="延长作用域链" tabindex="-1"><a class="header-anchor" href="#延长作用域链"><span>延长作用域链</span></a></h4><p>延长作用域链方法：</p><ul><li>try-catch 语句的 catch 块</li><li>with 语句</li></ul><p>解释说明：</p><ul><li>就是当执行流进入上面任何一个语句时，作用域链就会得到加长:</li><li>对 with 语句来说，会将指定的对象添加到作用域链中。</li><li>对 catch 语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。</li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">function buildUrl() {</span>
<span class="line">    var qs = &quot;?debug=true&quot;;</span>
<span class="line">    with(location){</span>
<span class="line">        var url = href + qs;</span>
<span class="line">}</span>
<span class="line">    return url; </span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="没有块级作用域" tabindex="-1"><a class="header-anchor" href="#没有块级作用域"><span>没有块级作用域</span></a></h4><h5 id="_1-声明变量" tabindex="-1"><a class="header-anchor" href="#_1-声明变量"><span>1. 声明变量</span></a></h5><ul><li>使用 var 声明的变量会自动被添加到最接近的环境中。</li><li>在函数内部，最接近的环境就是函数的局部环境;</li><li>在 with 语句中，最接近的环境是函数环境。</li><li>如果初始化变量时没有使用 var 声明，该变量会自 动被添加到全局环境。</li><li>!在严格模式下，初始化未经声明的变量会导致错误。</li></ul><h5 id="_2-查询标识符过程" tabindex="-1"><a class="header-anchor" href="#_2-查询标识符过程"><span>2. 查询标识符过程</span></a></h5><ul><li>当在某个环境中为了读取或写入而引用一个标识符时，必须通过搜索来确定该标识符实际代表什么。</li><li>搜索过程从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符。</li><li>如果在局部环境中找到了该标识符，搜索过程停止，变量就绪。</li><li>如果在局部环境中没有找到该变量名，则继续沿作用域链向上搜索。</li><li>搜索过程将一直追溯到全局环境的变量对象。</li><li>如果在全局环境中也没有找到这个标识符，则意味 着该变量尚未声明。</li></ul><h2 id="三、垃圾收集" tabindex="-1"><a class="header-anchor" href="#三、垃圾收集"><span>三、垃圾收集</span></a></h2><blockquote><p>JavaScript 具有自动垃圾收集机制，也就是说，执行环境会负责管理代码执行过程中使用的内存。<br> 垃圾收集原理：找出那些不再继续使用的变量，然后释放其占用的内存。垃圾收集器会按照固定的时间间隔(或代码执行中预定的收集时间)，周期性地执行这一操作。<br> 但并非所有情况下都像局部变量内存释放这么容易就能得出结论。</p></blockquote><p><strong>垃圾收集器必须跟踪哪个变量有用哪个变量没用，对于不再有用的变量打上标记，以备将来收回其占用的内存。通常有两个策略：</strong></p><h5 id="_1-标记清除" tabindex="-1"><a class="header-anchor" href="#_1-标记清除"><span>1.标记清除</span></a></h5><blockquote><p>当变量进入环境(例如，在函数中声明一个变量)时，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。<br> 而当变量离开环境时，则将其 标记为“离开环境”。<br> 可以使用任何方式来标记变量。比如，可以通过翻转某个特殊的位来记录一个变量何时进入环境， 或者使用一个“进入环境的”变量列表及一个“离开环境的”变量列表来跟踪哪个变量发生了变化。说 到底，如何标记变量其实并不重要，关键在于采取什么策略。</p></blockquote><h5 id="_2-引用计数" tabindex="-1"><a class="header-anchor" href="#_2-引用计数"><span>2.引用计数</span></a></h5><blockquote><p>引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。 如果同一个值又被赋给另一个变量，则该值的引用次数加 1。<br> 相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数减 1。当这个值的引用次数变成 0 时，则说明没有办法再访问这个值了，因而就可以将其占用的内存空间回收回来。</p></blockquote><p><strong>但很快它就遇到了一个严重的问题:</strong> 循环引用。循环引用指的是对象 A 中包含一个指向对象 B 的指针，而对象 B 中也包含一个指向对象 A 的 引用。</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">function problem(){</span>
<span class="line">    var objectA = new Object();</span>
<span class="line">    var objectB = new Object();</span>
<span class="line">   objectA.someOtherObject = objectB; </span>
<span class="line">    objectB.anotherObject = objectA;</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>采用引用计数策略的实现中，当函数执行完毕后，objectA 和 objectB 还 将继续存在，因为它们的引用次数永远不会是 0。假如这个函数被重复多次调用，就会导致大量内存得 不到回收。 <strong>放弃了引用计数方式</strong>，转而采用<strong>标记清除</strong>来实现其垃圾收集机制。可是，引用计数导致的麻烦并未就此终结。</p><h4 id="性能问题" tabindex="-1"><a class="header-anchor" href="#性能问题"><span>性能问题</span></a></h4><ul><li>垃圾收集器多长时间运行一次?</li></ul><h5 id="ie6-垃圾收集方案" tabindex="-1"><a class="header-anchor" href="#ie6-垃圾收集方案"><span>IE6 垃圾收集方案：</span></a></h5><blockquote><p>IE 的垃圾收集器是根据内存分配量运行的，具体一点说就是 256 个变量、4096 个对象(或数组)字面量和数组元素(slot)或者 64KB 的字符串。<br> 达到上述任何一个临界值，垃圾收集器就会运行。</p></blockquote><p>出现问题： 如果一个脚本中包含那么多变量，那么该脚本很可能会在其生命周期中一直保有那么多的变量。而这样一来，垃圾收集器就不得不频繁地运行。结果，由此引发的严重性能问题引发 IE7重写了其垃圾收集例程。</p><h5 id="ie7重写垃圾收集例程" tabindex="-1"><a class="header-anchor" href="#ie7重写垃圾收集例程"><span>IE7重写垃圾收集例程：</span></a></h5><blockquote><p>触发垃圾收集的变量分配、 字面量和(或)数组元素的临界值被调整为动态修正。IE7 中的各项临界值在初始时与 IE6 相等。<br> 如果 垃圾收集例程回收的内存分配量低于 15%，则变量、字面量和(或)数组元素的临界值就会加倍。<br> 如果 例程回收了85%的内存分配量，则将各种临界值重置回默认值。<br> 这一看似简单的调整，极大地提升了 IE 在运行包含大量 JavaScript 的页面时的性能。</p></blockquote><p>事实上，在有的浏览器中可以触发垃圾收集过程，但我们不建议这样做。 在 IE 中，调用 window.CollectGarbage()方法会立即执行垃圾收集。 在 Opera 7 及更 高版本中，调用 window.opera.collect()也会启动垃圾收集例程。</p><h4 id="管理内存" tabindex="-1"><a class="header-anchor" href="#管理内存"><span>管理内存</span></a></h4><p>优化内存占用的最佳方式，就是为执行中的代码只保存必要的数据。一旦数据不再有用，最好通过将其值设置为 null 来释放其引用——这个做法叫做解除引用(dereferencing)。 解除引用的真正作用是让值脱离 执行环境，以便垃圾收集器下次运行时将其回收。</p><h4 id="javascript-是一门具有自动垃圾收集机制的编程语言-垃圾收集总结" tabindex="-1"><a class="header-anchor" href="#javascript-是一门具有自动垃圾收集机制的编程语言-垃圾收集总结"><span>JavaScript 是一门具有自动垃圾收集机制的编程语言，垃圾收集总结：</span></a></h4><ul><li>离开作用域的值将被自动标记为可以回收，因此将在垃圾收集期间被删除。</li><li>“标记清除”是目前主流的垃圾收集算法，这种算法的思想是给当前不使用的值加上标记，然 后再回收其内存。</li><li>另一种垃圾收集算法是“引用计数”，这种算法的思想是跟踪记录所有值被引用的次数。JavaScript引擎目前都不再使用这种算法;但在IE 中访问非原生 JavaScript 对象(如 DOM 元素)时，这种 算法仍然可能会导致问题。</li><li>当代码中存在循环引用现象时，“引用计数”算法就会导致问题。</li><li>解除变量的引用不仅有助于消除循环引用现象，而且对垃圾收集也有好处。为了确保有效地回收内存，应该及时解除不再使用的全局对象、全局对象属性以及循环引用变量的引用。</li></ul>`,59)])])}const d=e(i,[["render",r]]),o=JSON.parse('{"path":"/fontend/class1/06.variable-scope-memory.html","title":"变量、作用域和内存","lang":"zh-CN","frontmatter":{},"git":{"updatedTime":1764128360000,"contributors":[{"name":"lumi","username":"lumi","email":"lumiya1228@gmail.com","commits":1,"url":"https://github.com/lumi"}],"changelog":[{"hash":"cf2f85e78da6745fae651d3e778926f1ac985f47","time":1764128360000,"email":"lumiya1228@gmail.com","author":"lumi","message":"docs: restructure front-end and offer sections, add new content and navigation links"}]},"filePathRelative":"fontend/class1/06.variable-scope-memory.md"}');export{d as comp,o as data};
