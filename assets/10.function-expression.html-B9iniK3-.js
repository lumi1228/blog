import{_ as a,a as s,d as e,g as i}from"./app-BXqgnaz2.js";const l={};function r(t,n){return i(),s("div",null,[...n[0]||(n[0]=[e(`<h1 id="函数表达式" tabindex="-1"><a class="header-anchor" href="#函数表达式"><span>函数表达式</span></a></h1><h5 id="主要内容" tabindex="-1"><a class="header-anchor" href="#主要内容"><span>主要内容</span></a></h5><blockquote><p>函数表达式的特征<br> 使用函数实现递归<br> 使用闭包定义私有变量</p></blockquote><h4 id="定义函数的方式有两种-函数声明、函数表达式" tabindex="-1"><a class="header-anchor" href="#定义函数的方式有两种-函数声明、函数表达式"><span>定义函数的方式有两种: 函数声明、函数表达式</span></a></h4><h5 id="_1-函数声明" tabindex="-1"><a class="header-anchor" href="#_1-函数声明"><span>1.函数声明：</span></a></h5><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">function functionName(arg0, arg1, arg2) { </span>
<span class="line">    //函数体</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>特征：函数声明提升，意思是在执行代码之前会先读取函数声明。这就意味着可以把函数声明放在调用它的语句后面。</li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">sayHi();</span>
<span class="line">function sayHi(){</span>
<span class="line">    alert(&quot;Hi!&quot;);</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>解析：不会抛出错误，因为在代码执行之前会先读取函数声明</p><h5 id="_2-函数表达式" tabindex="-1"><a class="header-anchor" href="#_2-函数表达式"><span>2.函数表达式</span></a></h5><ul><li>即创建一个函数并将它赋值给变量 functionName。 这种情况下创建的函数叫做匿名函数(也叫拉姆达函数)，因为 function 关键字后面没有标识符。</li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">var functionName = function(arg0, arg1, arg2){ </span>
<span class="line">    //函数体</span>
<span class="line">};</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>函数表达式与其他表达式一样，在使用前必须先赋值。</li></ul><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">sayHi(); //报错:函数还不存在 </span>
<span class="line">var sayHi = function(){</span>
<span class="line">    alert(&quot;Hi!&quot;);</span>
<span class="line">};</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="一、递归" tabindex="-1"><a class="header-anchor" href="#一、递归"><span>一、递归</span></a></h2><h4 id="基础用法" tabindex="-1"><a class="header-anchor" href="#基础用法"><span>基础用法</span></a></h4><blockquote><p>递归函数是在一个函数通过名字调用自身的情况下构成的</p></blockquote><p>递归阶乘函数：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line"> function factorial(num){</span>
<span class="line">    if (num &lt;= 1) {</span>
<span class="line">        return 1;</span>
<span class="line">    } else { </span>
<span class="line">        return num * factorial(num-1);</span>
<span class="line">    }</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>问题： 如上面的代码所示，在函数有名字，而且名字以后也不会变的情况下，这样定义没有问题。 若函数赋值给了另一个变量Anotherfactorial时，若factorial置为null，则Anotherfactorial 递归执行factorial，会报错；<br> 即这个函数的执行与函数名 factorial 紧紧耦合在了一起。</p><p>解决：为了消除这种紧密耦合的现象，可以像下面这样使用 arguments.callee</p><h4 id="arguments-callee实现递归" tabindex="-1"><a class="header-anchor" href="#arguments-callee实现递归"><span>arguments.callee实现递归</span></a></h4><p>前置知识：</p><blockquote><p>callee是arguments对象的属性。它可用于引用该函数的函数体内的当前正在执行的函数。<br> 当函数名称未知时，例如在没有名称的函数表达式中（也称为“匿名函数”），此功能很有用。</p></blockquote><p>arguments.callee实现递归：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">function factorial(num){</span>
<span class="line">    if (num &lt;= 1){</span>
<span class="line">        return 1;</span>
<span class="line">    } else {</span>
<span class="line">        return num * arguments.callee(num-1);</span>
<span class="line">    } </span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>通过使用 arguments.callee 代替函数名，可以确保无论怎样调用函数都不会出问题。 因此，在编写递归函数时，使用 arguments.callee 总比使用函数名更保险。</p><p>问题：但在<strong>严格模式</strong>下，不能通过脚本访问 arguments.callee，<strong>访问这个属性会导致错误</strong>。</p><p>解决：可以使用<strong>命名函数表达式</strong>来达成相同的结果。</p><h4 id="命名函数表达式实现递归" tabindex="-1"><a class="header-anchor" href="#命名函数表达式实现递归"><span>命名函数表达式实现递归</span></a></h4><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">var factorial = (</span>
<span class="line">    function f(num){</span>
<span class="line">        if (num &lt;= 1){</span>
<span class="line">            return 1;</span>
<span class="line">        } else {</span>
<span class="line">            return num * f(num-1);</span>
<span class="line">        } </span>
<span class="line">    }</span>
<span class="line">);</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>解析： 以上代码创建了一个名为 f()的命名函数表达式，然后将它赋值给变量 factorial。 即便把函数赋值给了另一个变量，函数的名字 f 仍然有效，所以递归调用照样能正确完成。 这种方式在严格模式和 非严格模式下都行得通。</p><h2 id="二、闭包" tabindex="-1"><a class="header-anchor" href="#二、闭包"><span>二、闭包</span></a></h2><blockquote><p>闭包是指有权访问<strong>另一个函数作用域中的变量</strong>的函数</p></blockquote><h5 id="创建闭包的常见方式-就是在一个函数内部创建另一个函数" tabindex="-1"><a class="header-anchor" href="#创建闭包的常见方式-就是在一个函数内部创建另一个函数"><span>创建闭包的常见方式：就是在一个函数内部创建另一个函数</span></a></h5><h5 id="当某个函数被调用时" tabindex="-1"><a class="header-anchor" href="#当某个函数被调用时"><span>当某个函数被调用时</span></a></h5><ul><li>会创建一个<strong>执行环境</strong>(execution context)及相应的<strong>作用域链</strong>。</li><li>然后，使用 arguments 和其他命名参数的值来 <strong>初始化</strong>函数的<strong>活动对象</strong>(activation object)。</li><li>但在作用域链中，外部函数的活动对象始终处于第二位，......直至作为作用域链终点的全局执行环境</li></ul><h4 id="_1-当普通函数被调用实例分析" tabindex="-1"><a class="header-anchor" href="#_1-当普通函数被调用实例分析"><span>① 当普通函数被调用实例分析</span></a></h4><p>当普通函数被调用时实例：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">function compare(value1, value2){</span>
<span class="line">    if (value1 &lt; value2){</span>
<span class="line">        return -1;</span>
<span class="line">    } else if (value1 &gt; value2){</span>
<span class="line">        return 1;</span>
<span class="line">    } else {</span>
<span class="line">        return 0; </span>
<span class="line">    }</span>
<span class="line">}</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>图 7-1 展示了包含上述关系的 compare()函数执行时的作用域链。</p><p>实例分析：</p><ul><li>在创建 compare()函数时，会<strong>创建</strong>一个预先包含全局变量对象的<strong>作用域链</strong>，这个作用域链被保存在内部的[[Scope]]属性中。</li><li>当调用 compare()函数时，会为函数创建一个执行环境，然后通过复制函数的[[Scope]]属性中的对象构建起执行环境的作用域链。此后，又有一个活动对象(在此作为变量对象使用)被创建并被推入执行环境作用域链的前端。</li><li>对于这个例子中 compare()函数的执行环境而言，其作用域链中包含两个变量对象:本地活动对象和全局变量对象。</li></ul><p>总结：</p><ul><li>后台的每个执行环境都有一个表示变量的对象——<strong>变量对象</strong>。</li><li>全局环境的变量对象始终存在，而像 compare()函数这样的局部环境的变量对象，则只在<strong>函数执行的过程中存在</strong>。</li><li>显然作用域链本质上是一个指向变量对象的指针列表，它只引用但不实际包含变量对象。</li><li>一般来讲，当函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域(全局执行环境的变量对象)。</li></ul><h4 id="_2-当闭包函数被调用实例分析" tabindex="-1"><a class="header-anchor" href="#_2-当闭包函数被调用实例分析"><span>② 当闭包函数被调用实例分析</span></a></h4><p>当闭包函数被调用时实例：</p><div class="language-text line-numbers-mode" data-highlighter="prismjs" data-ext="text"><pre><code class="language-text"><span class="line">//创建函数</span>
<span class="line">var compareNames = createComparisonFunction(&quot;name&quot;); //createComparisonFunction 内部定义了匿名函数</span>
<span class="line">//调用函数</span>
<span class="line">var result = compareNames({ name: &quot;Nicholas&quot; }, { name: &quot;Greg&quot; });</span>
<span class="line">//解除对匿名函数的引用(以便释放内存)</span>
<span class="line">compareNames = null;</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>图 7-2 展示调用 compareNames()的过程中产生的作用域链之间的关系。</p><p>实例分析：</p><ul><li>创建的比较函数被保存在变量 compareNames 中。</li><li>createComparisonFunction 内部定义了匿名函数；</li><li>在匿名函数从 createComparisonFunction()中被返回后，它的作用域链被初始化为包含 createComparisonFunction()函数的活动对象和全局变量对象。这样，匿名函数就可以访问在 createComparisonFunction()中定义的所有变量。</li><li>createComparisonFunction() 函数在<strong>执行完毕后</strong>，其<strong>活动对象也不会被销毁</strong>，因为<strong>匿名函数的作用域链仍然在引用这个活动对象</strong>。</li><li>换句话说，其执行环境的作用域链会被销毁，但它的活动对象仍然会留在内存中;直到匿名函数被销毁后，createComparisonFunction()的活动对象才会被销毁。</li><li>由此有了第三步：通过将 compareNames 设置为等于 null 解除该函数的引用，就等于通知垃圾回收例程将其清除。</li></ul><p>注意：</p><ul><li>由于闭包会携带包含它的函数的作用域，因此会比其他函数占用更多的内存。</li><li>过度使用闭包可能会导致内存占用过多，我们建议读者只在绝对必要时再考虑使用闭包。</li></ul><h3 id="_1-闭包与变量" tabindex="-1"><a class="header-anchor" href="#_1-闭包与变量"><span>1.闭包与变量</span></a></h3><h3 id="_2-关于this对象" tabindex="-1"><a class="header-anchor" href="#_2-关于this对象"><span>2.关于this对象</span></a></h3><h3 id="_3-内存泄漏" tabindex="-1"><a class="header-anchor" href="#_3-内存泄漏"><span>3.内存泄漏</span></a></h3><h2 id="三、模仿块级作用域" tabindex="-1"><a class="header-anchor" href="#三、模仿块级作用域"><span>三、模仿块级作用域</span></a></h2><h2 id="四、私有变量" tabindex="-1"><a class="header-anchor" href="#四、私有变量"><span>四、私有变量</span></a></h2><h3 id="_1-静态私有变量" tabindex="-1"><a class="header-anchor" href="#_1-静态私有变量"><span>1.静态私有变量</span></a></h3><h3 id="_2-模块模式" tabindex="-1"><a class="header-anchor" href="#_2-模块模式"><span>2.模块模式</span></a></h3><h3 id="_3-增强的模块模式" tabindex="-1"><a class="header-anchor" href="#_3-增强的模块模式"><span>3.增强的模块模式</span></a></h3>`,61)])])}const d=a(l,[["render",r]]),p=JSON.parse('{"path":"/fontend/class1/10.function-expression.html","title":"函数表达式","lang":"zh-CN","frontmatter":{},"git":{"updatedTime":1764128360000,"contributors":[{"name":"lumi","username":"lumi","email":"lumiya1228@gmail.com","commits":1,"url":"https://github.com/lumi"}],"changelog":[{"hash":"cf2f85e78da6745fae651d3e778926f1ac985f47","time":1764128360000,"email":"lumiya1228@gmail.com","author":"lumi","message":"docs: restructure front-end and offer sections, add new content and navigation links"}]},"filePathRelative":"fontend/class1/10.function-expression.md"}');export{d as comp,p as data};
